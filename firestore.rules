rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdmin() {
      return isSignedIn() &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    function isBlocked(targetUserId) {
      return exists(/databases/$(database)/documents/users/$(targetUserId)/blockedUsers/$(request.auth.uid));
    }

    function hasBlocked(targetUserId) {
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)/blockedUsers/$(targetUserId));
    }

    function isConnected(userId1, userId2) {
      return exists(/databases/$(database)/documents/connections/$(userId1 + '_' + userId2)) ||
             exists(/databases/$(database)/documents/connections/$(userId2 + '_' + userId1));
    }

    function meetsPrivacySettings(userId, field) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId)).data;
      let privacy = userDoc.privacy;

      // If no privacy settings, default to public
      if (!('privacy' in userDoc)) {
        return true;
      }

      // Check field-specific privacy
      if (!(field in privacy)) {
        return true; // Default to public if not specified
      }

      let setting = privacy[field];

      return setting == 'public' ||
             (setting == 'connections' && isConnected(request.auth.uid, userId)) ||
             (setting == 'private' && isOwner(userId));
    }

    // Users collection
    match /users/{userId} {
      // Anyone authenticated can read basic user info (filtered by privacy)
      allow read: if isSignedIn() &&
                    !isBlocked(userId) &&
                    !hasBlocked(userId);

      // Users can create their own profile
      allow create: if isOwner(userId) &&
                      request.resource.data.keys().hasAll(['email', 'createdAt']) &&
                      request.resource.data.createdAt == request.time;

      // Users can update their own profile, admins can update any profile
      allow update: if (isOwner(userId) || isAdmin()) &&
                      // Prevent users from changing their own role
                      (!('role' in request.resource.data) ||
                       isAdmin() ||
                       request.resource.data.role == resource.data.get('role', ''));

      // Only admins can delete users
      allow delete: if isAdmin();

      // Blocked users subcollection
      match /blockedUsers/{blockedUserId} {
        allow read: if isOwner(userId);
        allow create, delete: if isOwner(userId);
      }
    }

    // Connections collection
    match /connections/{connectionId} {
      // Users can read connections they're part of
      allow read: if isSignedIn() &&
                    (request.auth.uid == resource.data.fromUserId ||
                     request.auth.uid == resource.data.toUserId);

      // Users can create connection requests
      allow create: if isSignedIn() &&
                      request.auth.uid == request.resource.data.fromUserId &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.keys().hasAll(['fromUserId', 'toUserId', 'status', 'createdAt']) &&
                      request.resource.data.createdAt == request.time;

      // Users can update connections they're part of
      allow update: if isSignedIn() &&
                      (request.auth.uid == resource.data.fromUserId ||
                       request.auth.uid == resource.data.toUserId);

      // Users can delete their own connection requests
      allow delete: if isSignedIn() &&
                      (request.auth.uid == resource.data.fromUserId ||
                       request.auth.uid == resource.data.toUserId);
    }

    // Chats collection
    match /chats/{chatId} {
      // Users can read chats they're participants of
      allow read: if isSignedIn() &&
                    request.auth.uid in resource.data.participants;

      // Users can create chats they're part of
      allow create: if isSignedIn() &&
                      request.auth.uid in request.resource.data.participants &&
                      request.resource.data.participants.size() == 2 &&
                      request.resource.data.keys().hasAll(['participants', 'createdAt', 'lastMessage']) &&
                      request.resource.data.createdAt == request.time;

      // Participants can update chat metadata
      allow update: if isSignedIn() &&
                      request.auth.uid in resource.data.participants;

      // Messages subcollection
      match /messages/{messageId} {
        // Participants can read messages
        allow read: if isSignedIn() &&
                      request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // Participants can create messages
        allow create: if isSignedIn() &&
                        request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants &&
                        request.auth.uid == request.resource.data.senderId &&
                        request.resource.data.keys().hasAll(['senderId', 'text', 'createdAt']) &&
                        request.resource.data.createdAt == request.time;

        // Sender can update their own messages (for read status, etc.)
        allow update: if isSignedIn() &&
                        request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

        // Sender can delete their own messages
        allow delete: if isSignedIn() &&
                        request.auth.uid == resource.data.senderId;
      }
    }

    // Communities collection
    match /communities/{communityId} {
      // Anyone can read public communities
      allow read: if isSignedIn();

      // Anyone can create communities
      allow create: if isSignedIn() &&
                      request.auth.uid == request.resource.data.createdBy &&
                      request.resource.data.keys().hasAll(['name', 'description', 'createdBy', 'createdAt', 'members']) &&
                      request.resource.data.createdAt == request.time &&
                      request.auth.uid in request.resource.data.members;

      // Creator and admins can update communities
      allow update: if isSignedIn() &&
                      (request.auth.uid == resource.data.createdBy || isAdmin());

      // Only creator and admins can delete communities
      allow delete: if isSignedIn() &&
                      (request.auth.uid == resource.data.createdBy || isAdmin());

      // Channels subcollection
      match /channels/{channelId} {
        // Community members can read channels
        allow read: if isSignedIn() &&
                      request.auth.uid in get(/databases/$(database)/documents/communities/$(communityId)).data.members;

        // Community creator can create channels
        allow create: if isSignedIn() &&
                        request.auth.uid == get(/databases/$(database)/documents/communities/$(communityId)).data.createdBy &&
                        request.resource.data.keys().hasAll(['name', 'createdAt']) &&
                        request.resource.data.createdAt == request.time;

        // Community creator can update/delete channels
        allow update, delete: if isSignedIn() &&
                                 request.auth.uid == get(/databases/$(database)/documents/communities/$(communityId)).data.createdBy;

        // Messages in channels
        match /messages/{messageId} {
          // Community members can read messages
          allow read: if isSignedIn() &&
                        request.auth.uid in get(/databases/$(database)/documents/communities/$(communityId)).data.members;

          // Community members can create messages
          allow create: if isSignedIn() &&
                          request.auth.uid in get(/databases/$(database)/documents/communities/$(communityId)).data.members &&
                          request.auth.uid == request.resource.data.senderId &&
                          request.resource.data.keys().hasAll(['senderId', 'text', 'createdAt']) &&
                          request.resource.data.createdAt == request.time;

          // Sender or admins can delete messages
          allow delete: if isSignedIn() &&
                          (request.auth.uid == resource.data.senderId ||
                           isAdmin() ||
                           request.auth.uid == get(/databases/$(database)/documents/communities/$(communityId)).data.createdBy);
        }
      }
    }

    // Events collection
    match /events/{eventId} {
      // Anyone can read public events
      allow read: if isSignedIn();

      // Anyone can create events
      allow create: if isSignedIn() &&
                      request.auth.uid == request.resource.data.createdBy &&
                      request.resource.data.keys().hasAll(['title', 'description', 'createdBy', 'createdAt', 'participants']) &&
                      request.resource.data.createdAt == request.time &&
                      request.auth.uid in request.resource.data.participants;

      // Creator, participants (to join/leave), and admins can update events
      allow update: if isSignedIn() &&
                      (request.auth.uid == resource.data.createdBy ||
                       request.auth.uid in resource.data.participants ||
                       isAdmin());

      // Only creator and admins can delete events
      allow delete: if isSignedIn() &&
                      (request.auth.uid == resource.data.createdBy || isAdmin());
    }

    // Files collection
    match /files/{fileId} {
      // Community members can read files in their communities
      allow read: if isSignedIn() &&
                    request.auth.uid in get(/databases/$(database)/documents/communities/$(resource.data.communityId)).data.members;

      // Community members can upload files
      allow create: if isSignedIn() &&
                      request.auth.uid in get(/databases/$(database)/documents/communities/$(request.resource.data.communityId)).data.members &&
                      request.auth.uid == request.resource.data.uploadedBy &&
                      request.resource.data.keys().hasAll(['name', 'size', 'type', 'uploadedBy', 'communityId', 'createdAt']) &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.size <= 10485760; // 10MB limit

      // Uploader or admins can delete files
      allow delete: if isSignedIn() &&
                      (request.auth.uid == resource.data.uploadedBy || isAdmin());
    }

    // Reports collection (for content moderation)
    match /reports/{reportId} {
      // Only admins can read reports
      allow read: if isAdmin();

      // Any user can create a report
      allow create: if isSignedIn() &&
                      request.auth.uid == request.resource.data.reportedBy &&
                      request.resource.data.keys().hasAll(['reportedBy', 'type', 'reason', 'createdAt']) &&
                      request.resource.data.createdAt == request.time;

      // Only admins can update/delete reports
      allow update, delete: if isAdmin();
    }

    // Notifications collection
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isSignedIn() &&
                    request.auth.uid == resource.data.userId;

      // System can create notifications (Cloud Functions)
      allow create: if isSignedIn();

      // Users can update their own notifications (mark as read)
      allow update: if isSignedIn() &&
                      request.auth.uid == resource.data.userId;

      // Users can delete their own notifications
      allow delete: if isSignedIn() &&
                      request.auth.uid == resource.data.userId;
    }
  }
}
